package main

import (
	"fmt"
	"os"
	"reflect"
	"strings"
)

func GenClient(api any, outPutPath string) error {

	ts, err := GenerateTS(reflect.TypeOf(api), "RPCClient")
	if err != nil {
		return err
	}
	if err := os.WriteFile(outPutPath, []byte(ts), 0644); err != nil {
		return err
	}
	fmt.Println("Wrote", outPutPath)
	return nil
}

func GenerateTS(apiT reflect.Type, clientName string) (string, error) {
	var b strings.Builder

	// Header
	b.WriteString("// --- AUTO-GENERATED: api.gen.ts ---\n")
	b.WriteString("// Generated by generator. Do not edit by hand (unless you know what you do).\n\n")

	b.WriteString("// Types\n\n")

	structs := map[string]reflect.Type{}
	nMethods := apiT.NumMethod()
	for i := 0; i < nMethods; i++ {
		m := apiT.Method(i)
		for j := 0; j < m.Type.NumIn(); j++ {
			if j == 0 {
				continue
			}
			collectStructs(m.Type.In(j), structs)
		}
		if m.Type.NumOut() > 0 {
			collectStructs(m.Type.Out(0), structs)
		}
	}

	names := make([]string, 0, len(structs))
	for n := range structs {
		names = append(names, n)
	}
	sortStrings(names)

	for _, name := range names {
		st := structs[name]
		b.WriteString(fmt.Sprintf("export interface %s {\n", name))
		for i := 0; i < st.NumField(); i++ {
			f := st.Field(i)
			jsName := f.Name
			tag := f.Tag.Get("json")
			if tag != "" {
				parts := strings.Split(tag, ",")
				if parts[0] != "" {
					jsName = parts[0]
				}
			}
			optional := ""
			ft := f.Type
			if ft.Kind() == reflect.Ptr {
				optional = "?"
				ft = ft.Elem()
			}
			b.WriteString(fmt.Sprintf("  %s%s: %s;\n", jsName, optional, goTypeToTS(ft)))
		}
		b.WriteString("}\n\n")
	}

	b.WriteString("// Generic RPC method result\n")
	b.WriteString("export type RPCResult<T> = { data: T; error?: any };\n\n")

	b.WriteString(fmt.Sprintf("export interface %s {\n", clientName))
	for i := 0; i < nMethods; i++ {
		m := apiT.Method(i)
		params := []string{}
		for j := 0; j < m.Type.NumIn(); j++ {
			if j == 0 {
				continue
			}
			pname := fmt.Sprintf("arg%d", j-1)
			ptype := goTypeToTS(m.Type.In(j))
			params = append(params, fmt.Sprintf("%s: %s", pname, ptype))
		}
		resType := "any"
		if m.Type.NumOut() > 0 {
			resType = goTypeToTS(m.Type.Out(0))
		}
		b.WriteString(fmt.Sprintf("  %s(%s): Promise<RPCResult<%s>>;\n", m.Name, strings.Join(params, ", "), resType))
	}
	b.WriteString("}\n\n")

	b.WriteString(wsBackendTS(clientName))

	b.WriteString(fmt.Sprintf("\nexport function createBackend(url: string): %s {\n", clientName))
	b.WriteString("  const b = new WSBackend(url);\n")
	b.WriteString("  return b.api as unknown as " + clientName + ";\n}\n")

	return b.String(), nil
}

func collectStructs(t reflect.Type, m map[string]reflect.Type) {
	if t == nil {
		return
	}
	if t.Kind() == reflect.Ptr {
		t = t.Elem()
	}
	switch t.Kind() {
	case reflect.Struct:
		name := t.Name()
		if name == "" {
			// anonymous struct: skip named interface generation; will fallback to 'any' or inline handling
			return
		}
		if _, ok := m[name]; ok {
			return
		}
		m[name] = t
		for i := 0; i < t.NumField(); i++ {
			collectStructs(t.Field(i).Type, m)
		}
	case reflect.Slice, reflect.Array:
		collectStructs(t.Elem(), m)
	case reflect.Map:
		collectStructs(t.Elem(), m)
	}
}

func goTypeToTS(t reflect.Type) string {
	if t == nil {
		return "any"
	}
	if t.Kind() == reflect.Ptr {
		return goTypeToTS(t.Elem())
	}
	switch t.Kind() {
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
		reflect.Float32, reflect.Float64:
		return "number"
	case reflect.String:
		return "string"
	case reflect.Bool:
		return "boolean"
	case reflect.Struct:
		if t.Name() != "" {
			return t.Name()
		}
		var parts []string
		for i := 0; i < t.NumField(); i++ {
			f := t.Field(i)
			fn := f.Name
			tag := f.Tag.Get("json")
			if tag != "" {
				parts = append(parts, fmt.Sprintf("%s: %s", strings.Split(tag, ",")[0], goTypeToTS(f.Type)))
			} else {
				parts = append(parts, fmt.Sprintf("%s: %s", fn, goTypeToTS(f.Type)))
			}
		}
		return fmt.Sprintf("{ %s }", strings.Join(parts, "; "))
	case reflect.Slice, reflect.Array:
		return goTypeToTS(t.Elem()) + "[]"
	case reflect.Map:
		// map[string]X -> { [key: string]: X }
		key := t.Key()
		if key.Kind() == reflect.String {
			return fmt.Sprintf("{ [key: string]: %s }", goTypeToTS(t.Elem()))
		}
		return "any"
	default:
		return "any"
	}
}

func wsBackendTS(clientName string) string {
	return `
// --- Runtime WebSocket backend wrapper ---
// Usage:
//   import { createBackend } from './api.gen';
//   const backend = createBackend('ws://localhost:8080/ws');
//   const res = await backend.Add(1,2);

class WSBackend {
  private ws: WebSocket | null = null;
  private url: string;
  private callbacks: Record<string, (err: any, res: any) => void> = {};
  private counter = 0;
  private _api: any = null;
  private queue: Array<{ id: string, method: string, params: any[], resolve: Function, reject: Function }> = [];
  private reconnectDelay = 1000;
  private connected = false;

  constructor(url: string) {
    this.url = url;
    this._api = new Proxy({}, {
      get: (_t, method: string) => (...args: any[]) => this.call(method, args)
    });
    this.connect();
  }

  public get api() { return this._api; }

  private connect() {
    this.ws = new WebSocket(this.url);

    this.ws.onopen = () => {
      console.log("[WS] Connected to", this.url);
      this.connected = true;
      for (const item of this.queue) {
        this._send(item.id, item.method, item.params);
      }
      this.queue = [];
    };

    this.ws.onmessage = (evt) => {
      console.log("[WS] Received:", evt.data);
      let msg: any;
      try { msg = JSON.parse(evt.data); } catch { return; }
      const cb = this.callbacks[msg.id];
      if (!cb) return;

      if (msg.result && typeof msg.result === "object" && ("data" in msg.result || "error" in msg.result)) {
        const r = msg.result;
        cb(r.error, r.data);
      } else {
        cb(msg.error, msg.result);
      }
      delete this.callbacks[msg.id];
    };

    this.ws.onclose = () => {
      console.log("[WS] Disconnected. Reconnecting...");
      this.connected = false;
      setTimeout(() => this.connect(), this.reconnectDelay);
    };

    this.ws.onerror = (e) => {
      console.warn("[WS] Error:", e);
      this.ws?.close();
    };
  }

  private call(method: string, params: any[]): Promise<any> {
    const id = (++this.counter).toString();
    return new Promise((resolve, reject) => {
      this.callbacks[id] = (err, res) => {
        console.log("[WS] Callback", method, "id", id, "err:", err, "res:", res);
        resolve({ data: res, error: err });
      };

      if (this.connected && this.ws && this.ws.readyState === WebSocket.OPEN) {
        this._send(id, method, params);
      } else {
        console.log("[WS] Queueing call", method, id, params);
        this.queue.push({ id, method, params, resolve, reject });
      }
    });
  }

  private _send(id: string, method: string, params: any[]) {
    if (!this.ws) throw new Error("WebSocket not initialized");
    const msg = { id, method, params };
    console.log("[WS] Sending:", msg);
    this.ws.send(JSON.stringify(msg));
  }
}

`
}

func sortStrings(s []string) {
	for i := 0; i < len(s); i++ {
		for j := i + 1; j < len(s); j++ {
			if s[j] < s[i] {
				s[i], s[j] = s[j], s[i]
			}
		}
	}
}
